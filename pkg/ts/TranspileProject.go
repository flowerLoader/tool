package ts

import (
	"errors"
	"fmt"
	"os"
	"strings"

	log "github.com/AlbinoGeek/logxi/v1"
	"github.com/evanw/esbuild/pkg/api"
)

var (
	JS_BANNER = `/**
 * This file was generated by flowerLoader TypeScript Transpiler (esbuild)
 * DO NOT MODIFY THIS FILE DIRECTLY, YOUR CHANGES WILL BE OVERWRITTEN
 */`

	JS_FOOTER = `/**
 * This file was generated by flowerLoader TypeScript Transpiler (esbuild)
 * DO NOT MODIFY THIS FILE DIRECTLY, YOUR CHANGES WILL BE OVERWRITTEN
 */`
)

func TranspileProject(sourcePath, outputFilename string, opts ...BuildOption) error {
	buildOptions := api.BuildOptions{
		Bundle:        true,
		Format:        api.FormatESModule,
		LegalComments: api.LegalCommentsEndOfFile,
		Platform:      api.PlatformNode,

		Banner: map[string]string{
			"js": JS_BANNER,
		},
		Footer: map[string]string{
			"js": JS_FOOTER,
		},
	}

	// Apply any additional specified build options
	for _, opt := range opts {
		opt(&buildOptions)
	}

	// Set entrypoints if necessary
	if len(buildOptions.EntryPoints) == 0 {
		entrypoint, err := detectEntrypoint(sourcePath)
		if err != nil {
			return fmt.Errorf("failed to detect entrypoint: %w", err)
		}

		log.Debug("Detected entrypoint", "entrypoint", entrypoint)
		buildOptions.EntryPoints = []string{entrypoint}
	}

	if len(buildOptions.EntryPoints) == 0 {
		return errors.New("no entrypoints found or specified for transpilation")
	}

	// Set debug logging if necessary
	if buildOptions.LogLevel == api.LogLevelDebug {
		if err := setVariable(buildOptions.EntryPoints[0], "debuglogging", "true"); err != nil {
			return fmt.Errorf("failed to set debuglogging variable: %w", err)
		}
	}

	// Compile the TypeScript project
	log.Info("Transpiling TypeScript project",
		"sourcePath", sourcePath,
		"outputFilename", outputFilename)

	result := api.Build(buildOptions)
	if len(result.Errors) > 0 {
		fmt.Printf("Failed to transpile %v\n", sourcePath)
		for _, err := range result.Errors {
			fmt.Printf("%s\n", err.Text)
		}

		return errors.New("failed to transpile")
	}

	if len(result.OutputFiles) > 1 {
		return errors.New("unexpected >1 output files")
	}

	resultingJS := result.OutputFiles[0].Contents
	if !strings.HasSuffix(outputFilename, ".js") {
		outputFilename = fmt.Sprintf("%s.js", outputFilename)
	}

	log.Debug("Writing output file", "outputFilename", outputFilename)
	if err := os.WriteFile(outputFilename, resultingJS, 0644); err != nil {
		return fmt.Errorf("failed to write output file: %w", err)
	}

	return nil
}

type BuildOption func(*api.BuildOptions)

func WithDebugMode(debugMode bool) func(*api.BuildOptions) {
	return func(opts *api.BuildOptions) {
		if debugMode {
			opts.LogLevel = api.LogLevelDebug
		} else {
			opts.LogLevel = api.LogLevelInfo
		}
	}
}

func WithEntrypoints(entrypoints []string) func(*api.BuildOptions) {
	return func(opts *api.BuildOptions) {
		opts.EntryPoints = entrypoints
	}
}
